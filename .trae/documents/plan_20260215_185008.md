# Phase 3: API & Real-Time Notifications Plan

## 1. API Route Completion
*   **Context**: I already implemented most of the API routes (`/api/users`, `/api/courses`, etc.) in the previous step.
*   **Audit**: I need to double-check if all CRUD operations are fully implemented or if I only did the basics.
    *   `users`: GET, POST (Done). Missing PUT, DELETE?
    *   `courses`: GET, POST (Done). Missing PUT, DELETE?
    *   `enrollments`: POST, DELETE (Done).
    *   `grades`: GET, POST (Done).
    *   `payments`: GET, POST (Done).
    *   `notifications`: GET, PATCH (Done).
*   **Action**: I will refine these if needed, but the priority is the **Real-Time** aspect now.

## 2. Real-Time Notifications (SSE)
*   **Goal**: Implement Server-Sent Events (SSE) to push notifications to the client.
*   **Challenge**: Vercel/Serverless functions have timeouts, making long-lived SSE connections tricky. However, for a demo/MVP, we can use a standard route handler with a streaming response.
*   **Architecture**:
    *   **Endpoint**: `/api/notifications/subscribe` (GET)
        *   Keeps connection open.
        *   Listens for database changes (or uses a polling interval for simplicity in serverless).
    *   **Client Hook**: `useNotifications()`
        *   Connects to EventSource.
        *   Updates local state/toast on message.
    *   **Trigger**: When a notification is created via `prisma.notification.create`, we ideally want to push it. Since we don't have a pub/sub system (Redis/Pusher), we'll simulate this or use a simple polling mechanism within the SSE connection if direct event emission isn't possible across isolated serverless instances. *Better approach for Vercel*: Short polling is often more reliable than SSE on serverless free tiers, but I will implement SSE as requested, likely using a `setInterval` to check for new notifications in the stream.

## 3. Implementation Plan
1.  **SSE Endpoint**: Create `src/app/api/notifications/subscribe/route.ts`.
2.  **Notification Hook**: Create `src/hooks/use-notifications.ts`.
3.  **UI Integration**: Add a Toast/Notification display to the `DashboardLayout`.
4.  **Testing**: Trigger a notification creation and verify it appears.

## 4. Execution Steps
1.  **Create SSE Route**: Implement the streaming response.
2.  **Create Hook**: Implement the client-side logic.
3.  **Update Layout**: Integrate the hook into the main layout to show toasts.
4.  **Verify API**: Ensure the existing notification creation (e.g., system events) works.

*Self-Correction*: Since standard SSE in serverless can be flaky without an external broker (like Pusher), I will implement a robust polling-based fallback or a simple interval-based SSE that checks the DB every few seconds for new unread notifications.

